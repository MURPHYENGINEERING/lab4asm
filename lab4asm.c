#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <libgen.h>
#include <errno.h>
#include <stdbool.h>

#define LINE_MAX_LEN 1024
#define LABEL_MAX_LEN 32

#define MEMORY_WIDTH 16
#define MEMORY_DEPTH 256

typedef struct
{
  char name[LABEL_MAX_LEN];
  size_t addr;
} Label;

// Jump addresses
Label labels[1024];
size_t nLabels = 0;

// Current line number being read, for error reporting
size_t iInputLine = 0;
// Current program counter location, for labels
size_t curAddr = 0;


static void strip_file_extension(char* fname)
{
  char* end = fname + strlen(fname);

  while (end > fname && *end != '.')
  {
    --end;
  }

  if (end > fname)
  {
    *end = '\0';
  }
}


char* strip_whitespace(char* str)
{
  char* end;

  // Trim leading space
  while (isspace((unsigned char)*str))
    str++;

  if (*str == 0) // All spaces?
    return str;

  // Trim trailing space
  end = str + strlen(str) - 1;
  while (end > str && isspace((unsigned char)*end))
    end--;

  // Write new null terminator character
  end[1] = '\0';

  return str;
}


static void strip_comments(char* str)
{
  while (*str != 0 && *str != ';')
    ++str;
  *str = '\0';
}


static void emit_header(FILE* f, unsigned int width, unsigned int depth)
{
  fprintf(f,
    "-- Intel Memory Initialization File\n"
    "\n"
    "-- Generated by Lab4ASM\n"
    "-- for EEE 333 with Seth Abraham\n"
    "\n"
    "WIDTH=%d;\n"
    "DEPTH=%d;\n"
    "\n"
    "ADDRESS_RADIX=UNS;\n"
    "DATA_RADIX=BIN;\n"
    "\n"
    "CONTENT BEGIN\n",
    width, depth);
}


static bool find_label(char* line, bool notify)
{
  size_t end = strnlen(line, LINE_MAX_LEN) - 1;
  if (line[end] == ':')
  {
    line[end] = '\0';
    strlcpy(labels[nLabels].name, line, LABEL_MAX_LEN);
    labels[nLabels].addr = curAddr;
    ++nLabels;
    if (notify)
      printf("  %s = %lu on line %lu\n", labels[nLabels].name, curAddr, iInputLine);
    return true;
  }
  return false;
}


static void emit_opcode(FILE* of, char* mach)
{
  fprintf(of, "%s", mach);
}

static void emit_arg(FILE* of, size_t width)
{
  char* arg = strtok(NULL, " \t");
  fprintf(of, "[%s:%d]", arg, width);
}


static void emit_ternary(FILE* of)
{
  emit_arg(of, 4);
  emit_arg(of, 4);
  emit_arg(of, 4);
}


static void emit_binary(FILE* of)
{
  emit_arg(of, 4);
  emit_arg(of, 4);
}


static void emit_zero(FILE* of, size_t width)
{
  for (size_t i = 0; i < width; ++i)
    fprintf(of, "0");
}


static void translate_line(char* line, FILE* of)
{
  char* tok = strtok(line, " \t");

  char* opcode = tok;
  fprintf(of, "%s ", tok);

  if (strcmp(opcode, "LDI") == 0) {
    emit_opcode(of, "0001");
    emit_arg(of, 8);
    emit_arg(of, 4);
  }
  else if (strcmp(opcode, "ADD") == 0) {
    emit_opcode(of, "0010");
    emit_ternary(of);
  }
  else if (strcmp(opcode, "ADI") == 0) {
    emit_opcode(of, "0011");
    emit_ternary(of);
  }
  else if (strcmp(opcode, "SUB") == 0) {
    emit_opcode(of, "0100");
    emit_ternary(of);
  }
  else if (strcmp(opcode, "MUL") == 0) {
    emit_opcode(of, "0101");
    emit_ternary(of);
  }
  else if (strcmp(opcode, "DIV") == 0) {
    emit_opcode(of, "0110");
    emit_ternary(of);
  }
  else if (strcmp(opcode, "INC") == 0) {
    emit_opcode(of, "1010");
    emit_arg(of, 4);
    emit_zero(of, 4);
    emit_arg(of, 4);
  }
  else if (strcmp(opcode, "DEC") == 0) {
    emit_opcode(of, "1000");
    emit_arg(of, 4);
    emit_zero(of, 4);
    emit_arg(of, 4);
  }
  else if (strcmp(opcode, "OR") == 0) {
    emit_opcode(of, "1001");
    emit_ternary(of);
  }
  else if (strcmp(opcode, "AND") == 0) {
    emit_opcode(of, "1010");
    emit_ternary(of);
  }
  else if (strcmp(opcode, "XOR") == 0) {
    emit_opcode(of, "1011");
    emit_ternary(of);
  }
  else if (strcmp(opcode, "COMP") == 0) {
    emit_opcode(of, "1100");
    emit_zero(of, 4);
    emit_binary(of);
  }
  else if (strcmp(opcode, "JMP") == 0) {
    emit_opcode(of, "1101");
    emit_arg(of, 8);
    emit_zero(of, 4);
  }
  else if (strcmp(opcode, "CMPJ") == 0) {
    emit_opcode(of, "1110");
    emit_ternary(of);
  }
  else if (strcmp(opcode, "NOP") == 0) {
    emit_opcode(of, "1111");
    emit_zero(of, 12);
  }
  else if (strcmp(opcode, "HALT") == 0) {
    emit_opcode(of, "0000");
    emit_zero(of, 12);
  }

  fprintf(of, "\n");
}


static void translate_file(FILE* inFile, FILE* outFile)
{
  char* line = (char*)malloc(LINE_MAX_LEN);
  size_t len = 0;

  for (size_t pass = 0; pass < 2; ++pass)
  {
    fseek(inFile, 0, 0);
    iInputLine = 0;
    curAddr = 0;

    if (pass == 0)
      printf("\nLabels\n\n");
    else
      printf("\nInstructions\n\n");

    int read = getline(&line, &len, inFile);
    while (read > -1)
    {
      ++iInputLine;

      strip_comments(line);
      char* cleanLine = strip_whitespace(line);

      if (*cleanLine != 0)
      {
        if (!find_label(cleanLine, (pass == 0))) {
          if (pass == 1)
            translate_line(cleanLine, outFile);
          ++curAddr;
        }
      }

      read = getline(&line, &len, inFile);
    }

    if (errno)
    {
      printf("\n! Error reading line from input file (%d): %s", errno, strerror(errno));
      break;
    }
  }

  free(line);
}


int main(int argc, char* argv[])
{
  char* inFilename = argv[1];
  char* outFilename;

  inFilename = (argc > 1) ? argv[1] : "lab4.asm";

  if (argc > 2)
  {
    outFilename = argv[2];
  }
  else
  {
    char buf[1024];
    strncpy(buf, basename(inFilename), sizeof(buf) - 1);
    strip_file_extension(buf);
    strncat(buf, ".mif", sizeof(buf) - 1);
    outFilename = buf;
  }

  printf("Lab4ASM - by Matt Murphy, for EEE333 wth Seth Abraham\n");
  printf("  Input file:\t%s\n  Output file:\t%s\n", inFilename, outFilename);

  FILE* inFile = fopen(inFilename, "r");
  if (!inFile)
  {
    printf("\n! Input file does not exist\n\n");
    return -1;
  }

  FILE* outFile = fopen(outFilename, "w");
  if (!outFile)
  {
    printf("\n! Couldn't open output file '%s' for writing", outFilename);
    fclose(inFile);
    return -1;
  }

  emit_header(outFile, MEMORY_WIDTH, MEMORY_DEPTH);

  translate_file(inFile, outFile);

  fprintf(outFile, "END;");

  fclose(inFile);
  fclose(outFile);

  return 0;
}

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <strings.h>
#include <ctype.h>
#include <libgen.h>
#include <errno.h>
#include <stdbool.h>

#define LINE_MAX_LEN 1024
#define LABEL_MAX_LEN 32

#define MEMORY_WIDTH 16
#define MEMORY_DEPTH 256

#define DELIM " \t"

typedef struct
{
  char name[LABEL_MAX_LEN];
  size_t addr;
} Label;

// Jump addresses
Label labels[1024];
size_t nLabels = 0;

// Current line number being read, for error reporting
size_t iInputLine = 0;
// Current program counter location, for labels
size_t curAddr = 0;

size_t longestLineLen = 0;


static void strip_file_extension(char* fname)
{
  char* end = fname + strlen(fname);

  while (end > fname && *end != '.')
    --end;

  if (end > fname)
    *end = '\0';
}


static char* strip_whitespace(char* str)
{
  char* end;

  // Trim leading space
  while (isspace((unsigned char)*str))
    str++;

  if (*str == 0) // All spaces?
    return str;

  // Trim trailing space
  end = str + strlen(str) - 1;
  while (end > str && isspace((unsigned char)*end))
    end--;

  // Write new null terminator character
  end[1] = '\0';

  return str;
}


static void strip_comments(char* str)
{
  while (*str != 0 && *str != ';')
    ++str;
  *str = '\0';
}


static void expected(char const* msg)
{
  printf("\n\n! Expected %s at line %lu\n\n", msg, iInputLine);
  exit(1);
}


static void emit_header(FILE* f)
{
  fprintf(f,
    "-- Intel Memory Initialization File\n"
    "\n"
    "-- Generated by Lab4ASM by Matthew Murphy\n"
    "-- for EEE 333 with Seth Abraham\n"
    "\n"
    "WIDTH=%d;\n"
    "DEPTH=%d;\n"
    "\n"
    "ADDRESS_RADIX=UNS;\n"
    "DATA_RADIX=BIN;\n"
    "\n"
    "CONTENT BEGIN\n",
    MEMORY_WIDTH, MEMORY_DEPTH);
}


static bool find_label(char* line, bool notify)
{
  size_t end = strnlen(line, LINE_MAX_LEN) - 1;
  if (line[end] == ':')
  {
    line[end] = '\0';
    if (strlen(line) == 0)
      expected("label declaration");

    strlcpy(labels[nLabels].name, line, LABEL_MAX_LEN);
    labels[nLabels].addr = curAddr;
    if (notify)
      printf("  %s = %lu on line %lu\n", labels[nLabels].name, curAddr, iInputLine);
    ++nLabels;
    return true;
  }
  return false;
}


static void emit_opcode(FILE* of, char const* mach)
{
  fprintf(of, "  %lu : %s", curAddr, mach);
  printf("  %s", mach);
}


static void emit_bits(FILE* of, unsigned int value, size_t width)
{
  for (size_t i = 0; i < width; ++i) {
    fprintf(of, "%d", (value >> (width - 1 - i)) & 1);
    printf("%d", (value >> (width - 1 - i)) & 1);
  }
}


static void emit_register(FILE* of, char const* arg, size_t width)
{
  unsigned int value = toupper(*arg) - 'A';
  emit_bits(of, value, width);
}


static void emit_literal_hex(FILE* of, char const* arg, size_t width)
{
  emit_bits(of, strtoul(arg, NULL, 16), width);
}


static void emit_literal_bin(FILE* of, char const* arg, size_t width)
{
  emit_bits(of, strtoul(arg + 2, NULL, 2), width);
}


static void emit_literal_dec(FILE* of, char const* arg, size_t width)
{
  emit_bits(of, strtoul(arg, NULL, 10), width);
}


static void emit_arg_ex(FILE* of, char const* arg, size_t width)
{
  if (toupper(*arg) >= 'A' && toupper(*arg) - 'A' < 16) {
    emit_register(of, arg, width);
  }
  else {
    if (*arg == '0') {
      if (*(arg + 1) == 'x') {
        emit_literal_hex(of, arg, width);
        return;
      }
      else if (*(arg + 1) == 'b') {
        emit_literal_bin(of, arg, width);
        return;
      }
    }
    emit_literal_dec(of, arg, width);
  }
}


static void emit_arg(FILE* of, size_t width)
{
  char* arg = strtok(NULL, DELIM);
  if (arg == NULL)
    expected("argument");

  emit_arg_ex(of, arg, width);
}


static void emit_ternary(FILE* of)
{
  emit_arg(of, 4);
  emit_arg(of, 4);
  emit_arg(of, 4);
}


static void emit_binary(FILE* of)
{
  emit_arg(of, 4);
  emit_arg(of, 4);
}


static void emit_zero(FILE* of, size_t width)
{
  for (size_t i = 0; i < width; ++i) {
    fprintf(of, "0");
    printf("0");
  }
}


static void emit_absolute_label(FILE* of, size_t width)
{
  char* arg = strtok(NULL, DELIM);
  if (arg == NULL)
    expected("label or absolute jump address");
  
  if (isalpha(*arg)) {
    for (size_t i = 0; i < nLabels; ++i) {
      Label* label = &labels[i];
      if (strcasecmp(label->name, arg) == 0) {
        emit_bits(of, label->addr, width);
        return;
      }
    }
    char buf[128];
    snprintf(buf, sizeof(buf)-1, "label ('%s' does not exist)", arg);
    expected(buf);
  }
  else {
    emit_arg_ex(of, arg, width);
  }
}


static void emit_relative_label(FILE* of, size_t width)
{
  char* arg = strtok(NULL, DELIM);
  if (arg == NULL)
    expected("label or relative jump address");
  
  if (isalpha(*arg)) {
    for (size_t i = 0; i < nLabels; ++i) {
      Label* label = &labels[i];
      if (strcasecmp(label->name, arg) == 0) {
        size_t offset = label->addr - curAddr;
        emit_bits(of, offset, width);
        return;
      }
    }
    char buf[128];
    snprintf(buf, sizeof(buf)-1, "label ('%s' does not exist)", arg);
    expected(buf);
  }
  else {
    emit_arg_ex(of, arg, width);
  }
}


static bool isop(char const* search, char const* match)
{
  return strcasecmp(search, match) == 0;
}


static void translate_line(char* line, FILE* of)
{
  char buf[10];
  sprintf(buf, "  %%-%lus", longestLineLen + 4);
  printf(buf, line);

  char* tok = strtok(line, DELIM);

  if (tok == NULL) {
    expected("opcode");
  }

  char* opcode = tok;

  if (isop(opcode, "LDI")) {
    emit_opcode(of, "0001");
    emit_arg(of, 8);
    emit_arg(of, 4);
  }
  else if (isop(opcode, "ADD")) {
    emit_opcode(of, "0010");
    emit_ternary(of);
  }
  else if (isop(opcode, "ADI")) {
    emit_opcode(of, "0011");
    emit_ternary(of);
  }
  else if (isop(opcode, "SUB")) {
    emit_opcode(of, "0100");
    emit_ternary(of);
  }
  else if (isop(opcode, "MUL")) {
    emit_opcode(of, "0101");
    emit_ternary(of);
  }
  else if (isop(opcode, "DIV")) {
    emit_opcode(of, "0110");
    emit_ternary(of);
  }
  else if (isop(opcode, "INC")) {
    emit_opcode(of, "0111");
    emit_arg(of, 4);
    emit_zero(of, 4);
    emit_arg(of, 4);
  }
  else if (isop(opcode, "DEC")) {
    emit_opcode(of, "1000");
    emit_arg(of, 4);
    emit_zero(of, 4);
    emit_arg(of, 4);
  }
  else if (isop(opcode, "OR")) {
    emit_opcode(of, "1001");
    emit_ternary(of);
  }
  else if (isop(opcode, "AND")) {
    emit_opcode(of, "1010");
    emit_ternary(of);
  }
  else if (isop(opcode, "XOR")) {
    emit_opcode(of, "1011");
    emit_ternary(of);
  }
  else if (isop(opcode, "COMP")) {
    emit_opcode(of, "1100");
    emit_zero(of, 4);
    emit_binary(of);
  }
  else if (isop(opcode, "JMP")) {
    emit_opcode(of, "1101");
    emit_absolute_label(of, 8);
    emit_zero(of, 4);
  }
  else if (isop(opcode, "CMPJ")) {
    emit_opcode(of, "1110");
    emit_binary(of);
    emit_relative_label(of, 4);
  }
  else if (isop(opcode, "NOP")) {
    emit_opcode(of, "1111");
    emit_zero(of, 12);
  }
  else if (isop(opcode, "HALT")) {
    emit_opcode(of, "0000");
    emit_zero(of, 12);
  }
  else {
    char buf[128];
    snprintf(buf, sizeof(buf) - 1, "opcode ('%s' is not valid)", opcode);
    expected(buf);
  }

  fprintf(of, ";\n");
  printf(";\n");
}


static void translate_file(FILE* inFile, FILE* outFile)
{
  char* line = (char*)malloc(LINE_MAX_LEN);
  size_t len = 0;

  for (size_t pass = 0; pass < 2; ++pass)
  {
    fseek(inFile, 0, 0);
    iInputLine = 0;
    curAddr = 0;

    if (pass == 0)
      printf("\nLabels\n\n");
    else
      printf("\nInstructions\n\n");

    int read = getline(&line, &len, inFile);
    while (read > -1)
    {
      ++iInputLine;

      strip_comments(line);
      char* cleanLine = strip_whitespace(line);

      if (*cleanLine != 0)
      {
        size_t len = strlen(cleanLine);
        if (len > longestLineLen)
          longestLineLen = len;

        if (!find_label(cleanLine, (pass == 0))) {
          if (pass == 1)
            translate_line(cleanLine, outFile);
          ++curAddr;
        }
      }

      read = getline(&line, &len, inFile);
    }

    if (errno)
    {
      printf("\n! Error reading line from input file (%d): %s", errno, strerror(errno));
      break;
    }
  }

  free(line);
}


int main(int argc, char* argv[])
{
  char* inFilename = argv[1];
  char* outFilename;

  inFilename = (argc > 1) ? argv[1] : "lab4.asm";

  if (argc > 2)
  {
    outFilename = argv[2];
  }
  else
  {
    char buf[1024];
    strncpy(buf, basename(inFilename), sizeof(buf) - 1);
    strip_file_extension(buf);
    strncat(buf, ".mif", sizeof(buf) - 1);
    outFilename = buf;
  }

  printf("Lab4ASM - by Matt Murphy, for EEE333 wth Seth Abraham\n");
  printf("  Input file:\t%s\n  Output file:\t%s\n", inFilename, outFilename);

  FILE* inFile = fopen(inFilename, "r");
  if (!inFile)
  {
    printf("\n! Input file does not exist\n\n");
    return -1;
  }

  FILE* outFile = fopen(outFilename, "w");
  if (!outFile)
  {
    printf("\n! Couldn't open output file '%s' for writing", outFilename);
    fclose(inFile);
    return -1;
  }

  emit_header(outFile);

  translate_file(inFile, outFile);

  fprintf(outFile, "  [%lu..%d] : 0000000000000000;\n", curAddr, MEMORY_DEPTH - 1);
  fprintf(outFile, "END;");

  fclose(inFile);
  fclose(outFile);

  printf("\n");

  return 0;
}
